{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 1464c4a3f1e9587f14da","webpack:///./tiled-hull.js","webpack:///./index.js","webpack:///./polygon-edge.js","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/convex.js","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/format.js","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/grid.js","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/hull.js","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/intersect.js"],"names":["phaserTiledHull","tilemapLayer","tileIndices","tileProperty","checkCollide","clusters","calculateClusters","pointHulls","calculateHullPoints","polyHulls","buildPolygons","hulls","entries","i","polyHull","hull","edge","push","tilemap","map","getTile","tx","ty","index","x","width","y","height","tile","checkTile","findTileInClusters","cluster","recursivelySearchNeighbors","includes","properties","collides","indexOf","searchTile","points","left","top","right","bottom","hulljs","polygons","hullPoints","edges","currentEdge","Phaser","Line","segment","length","checkIfCollinear","start","end","clone","firstLine","shift","lastLine","pop","combinedLine","line1","line2","dx1","dy1","dx2","dy2","module","exports","require","default","PolygonEdge","line","hullIndex","midpoint","midPoint","normal","_getOutwardNormal","shapeId","Point","setMagnitude"],"mappings":"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C;AAClC;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL,mCAAmC;AACnC;AACA;AACA;AACA,KAAK;;AAEL,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sB;;;;;;;AC1EA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA,mDAAmD,UAAU;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA,6E;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,sDAAsD;;AAEtD;AACA;;AAEA,2DAA2D;AAC3D;;AAEA,sB;;;;;;AC1MA,sC;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2B","file":"phaser-tiled-hull.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phaserTiledHull\"] = factory();\n\telse\n\t\troot[\"phaserTiledHull\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1464c4a3f1e9587f14da","import hulljs from \"hull.js\"; // JS extension required\r\nimport PolygonEdge from \"./polygon-edge\";\r\n\r\n/**\r\n * A function to take a tilemap layer and process its tiles into clusters. This returns an array of\r\n * polygons - each polygon encloses a separate cluster of tiles in the tilemap layer.\r\n *\r\n * @param {Phaser.TilemapLayer} tilemapLayer The tilemap layer to use for hull calculation.\r\n * @param {object} [options = {}] Options for filtering the tiles and only allowing certain tiles to\r\n * be added to the final hulls. If no options specified, then all tiles in the layer will be\r\n * processed and added to a hull. If multiple options are specified, then a tile only has to match\r\n * ONE of the options to be added to a hull.\r\n * @param {number[]} [options.tileIndices = null] An array of tile indices to use for determining\r\n * which tiles should be clustered together. If a tile's index matches an index in the array, it\r\n * will be added to a hull.\r\n * @param {string} [options.tileProperty = null] The name of a property on tiles (set in Tiled) to\r\n * use for determining which tiles should be clustered together. If the property is true (or truthy)\r\n * on a tile, it will be added to a hull.\r\n * @param {boolean} [options.checkCollide = false] Whether or not a tile's collide property should\r\n * be used for determining which tiles should be clustered together. If true, then colliding tiles\r\n * will be added to a hull.\r\n * @returns {Array.<PolygonEdge[]>} An array where each element represents a polygon. The polygons\r\n * are stored as an array of PolygonEdge instances.\r\n */\r\nexport default function phaserTiledHull(tilemapLayer, {tileIndices = null, tileProperty = null, \r\n        checkCollide = false} = {}) {\r\n    // Separate the tilemap layer into an array of clustered tiles\r\n    const clusters = calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide);\r\n    // Take the clustered tiles and calculate a hull for each cluster\r\n    const pointHulls = calculateHullPoints(clusters);\r\n    // Take the point hulls and turn them into polygon representations (i.e. connect the dots)\r\n    const polyHulls = buildPolygons(pointHulls);\r\n    // Turn the lines in polyHulls into PolygonEdge instances, pre-caching some helpful info like\r\n    // the edge normals\r\n    const hulls = [];\r\n    for (const [i, polyHull] of polyHulls.entries()) {\r\n        const hull = [];\r\n        for (const edge of polyHull) {\r\n            hull.push(new PolygonEdge(edge, i));\r\n        }\r\n        hulls.push(hull);\r\n    }\r\n    return hulls;\r\n}\r\n\r\nfunction calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide) {\r\n    const tilemap = tilemapLayer.map;\r\n    const clusters = [];\r\n    const getTile = (tx, ty) => tilemap.getTile(tx, ty, tilemapLayer.index);\r\n    \r\n    // Loop over all tiles in the map and kick off recursive cluster building\r\n    for (var x = 0; x < tilemap.width; x++) {\r\n        for (var y = 0; y < tilemap.height; y++) {\r\n            const tile = getTile(x, y);\r\n            if (checkTile(tile) && !findTileInClusters(tile)) {\r\n                const cluster = [];\r\n                recursivelySearchNeighbors(x, y, cluster);\r\n                clusters.push(cluster);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check to make sure the tile passes the checks, i.e. it is allowed to be in a cluster\r\n    function checkTile(tile) {\r\n        // No tile, ignore\r\n        if (!tile) return false;\r\n        // If an array of indices was provided, tile's index must be in that array\r\n        if (tileIndices && tileIndices.includes(tile.index)) return true;\r\n        // If a tile property was provided, the tile must have a truthy value for that property\r\n        if (tileProperty && tile.properties[tileProperty]) return true;\r\n        // If we only care about colliding tiles, make sure the tile collides\r\n        if (checkCollide && tile.collides) return true;\r\n        // Tile didn't pass any checks, ignore\r\n        return false;\r\n    }\r\n\r\n    function recursivelySearchNeighbors(x, y, cluster) {\r\n        // If tile passes the checks and is not already in the cluster, add it and recursively check\r\n        // the neighbors. Note: There's no chance of a tile being a member of two separate clusters.\r\n        const tile = getTile(x, y);\r\n        if (checkTile(tile) && (cluster.indexOf(tile) === -1)) {\r\n            cluster.push(tile); // Add the current tile\r\n            // Search the neighbors\r\n            recursivelySearchNeighbors(x, y - 1, cluster);\r\n            recursivelySearchNeighbors(x, y + 1, cluster);\r\n            recursivelySearchNeighbors(x + 1, y, cluster);\r\n            recursivelySearchNeighbors(x - 1, y, cluster);\r\n        }\r\n    }\r\n\r\n    function findTileInClusters(searchTile) {\r\n        for (const cluster of clusters) {\r\n            for (const tile of cluster) {\r\n                if (searchTile === tile) return cluster;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    return clusters;\r\n}\r\n\r\nfunction calculateHullPoints(clusters) {\r\n    const hulls = [];\r\n\r\n    // Loop over each cluster of tiles in clusters and calculate a polygon hull\r\n    for (const cluster of clusters) {\r\n        // Find all the points - i.e. the corners of each tile in the cluster\r\n        const points = [];\r\n        for (const tile of cluster) {\r\n            points.push(\r\n                [tile.left, tile.top],\r\n                [tile.right, tile.top],                \r\n                [tile.left, tile.bottom],                \r\n                [tile.right, tile.bottom]\r\n            );\r\n        }\r\n\r\n        // Use hull.js to find a hull (e.g. points in clockwise order). The second parameter is the \r\n        // concavity of the hull, with 1 being maximally concave.  \r\n        const hull = hulljs(points, 1);\r\n        hulls.push(hull);\r\n    }\r\n\r\n    return hulls;\r\n}\r\n\r\nfunction buildPolygons(hulls) {\r\n    const polygons = [];\r\n\r\n    for (const hullPoints of hulls) {\r\n        const edges = [];\r\n\r\n        // Walk along the line segments of the hull, collapsing collinear lines into a single edge\r\n        let currentEdge = new Phaser.Line(...hullPoints[0], ...hullPoints[1]);\r\n        let segment;\r\n        for (let i = 1; i < hullPoints.length; i++) {\r\n            // Get the next line segment - starts from the endpoint of the last segment\r\n            segment = new Phaser.Line(...hullPoints[i - 1], ...hullPoints[i]);\r\n\r\n            if (checkIfCollinear(currentEdge, segment)) {\r\n                // If the current edge and line segment are collinear, then we haven't reached the\r\n                // end of the edge yet. Extend the edge to contain the segment.\r\n                currentEdge = new Phaser.Line(\r\n                    currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y\r\n                );\r\n            } else {\r\n                // We've reached a corner, so the edge is done. Save it and start a new one.\r\n                edges.push(currentEdge);\r\n                currentEdge = segment.clone();             \r\n            }\r\n        }\r\n\r\n        // Process the last line segment - connecting the last point back around to the first point\r\n        segment = new Phaser.Line(...hullPoints[hullPoints.length - 1], ...hullPoints[0]);\r\n        if (checkIfCollinear(currentEdge, segment)) {\r\n            // Extend the edge and add it (since it wasn't added by the loop above)\r\n            currentEdge = new Phaser.Line(\r\n                currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y\r\n            );\r\n            edges.push(currentEdge);\r\n        } else {\r\n            // Corner - add the edge and the next segment \r\n            edges.push(currentEdge);\r\n            edges.push(segment);\r\n        }\r\n\r\n        // Determine whether the last edge and the first edge need to be merged (if the points in\r\n        // the hull started midway through an edge)\r\n        if (checkIfCollinear(edges[0], edges[edges.length - 1])) {\r\n            const firstLine = edges.shift();\r\n            const lastLine = edges.pop();\r\n            var combinedLine = new Phaser.Line(\r\n                firstLine.start.x, firstLine.start.y, lastLine.end.x, lastLine.end.y\r\n            );\r\n            edges.push(combinedLine);\r\n        }\r\n\r\n        // Add the final lines to the polygon\r\n        polygons.push(edges);\r\n    }\r\n    \r\n    return polygons;\r\n}\r\n\r\nfunction checkIfCollinear(line1, line2) {\r\n    // To check if two slopes are equal:\r\n    //  lineDeltaY / lineDeltaX = segmentDeltaY / segmentDeltaX\r\n    // But to avoid dividing by zero:\r\n    //  (lineDeltaX * segmentDeltaY) - (lineDeltaY * segmentDeltaX) = 0\r\n    const dx1 = line1.end.x - line1.start.x;\r\n    const dy1 = line1.end.y - line1.start.y;\r\n    const dx2 = line2.end.x - line2.start.x;\r\n    const dy2 = line2.end.y - line2.start.y;\r\n    return ((dx1 * dy2) - (dy1 * dx2)) === 0;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./tiled-hull.js","// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\r\n// up with something having to do \"phaserTiledHull.default(...)\" instead of \"phaserTiledHull(...)\"\r\nmodule.exports = require(\"./tiled-hull\").default;\n\n\n// WEBPACK FOOTER //\n// ./index.js","/**\r\n * Small class for precomuting some useful information about an edge of a polygon - the line,\r\n * length, midpoint, normal. This class isn't exposed directly by the module, but is used in the\r\n * return type of {@link phaserTiledHull}.\r\n */\r\nexport default class PolygonEdge {\r\n    constructor(line, hullIndex) {\r\n        /**\r\n         * The line that makes up the edge\r\n         * @type {Phaser.Line}\r\n         */\r\n        this.line = line;\r\n\r\n        /** @type {number} */\r\n        this.length = line.length;\r\n\r\n        /** @type {Phaser.Point} */\r\n        this.midpoint = line.midPoint();\r\n        \r\n        /** \r\n         * Outward-facing normal vector as a point, normalized to unit length\r\n         * @type {Phaser.Point} \r\n         * */\r\n        this.normal = this._getOutwardNormal(line);\r\n\r\n        /**\r\n         * Identifies which hull index this edge is a part of \r\n         * @type {number} \r\n         * */\r\n        this.shapeId = hullIndex;\r\n    }\r\n\r\n    _getOutwardNormal(line) {\r\n        // The wall lines are returned from hull.js in clockwise order, so the outward facing normal\r\n        // is the following\r\n        return new Phaser.Point((line.end.y - line.start.y), -(line.end.x - line.start.x))\r\n            .setMagnitude(1);\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./polygon-edge.js","function _cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\nfunction _upperTangent(pointset) {\n    var lower = [];\n    for (var l = 0; l < pointset.length; l++) {\n        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {\n            lower.pop();\n        }\n        lower.push(pointset[l]);\n    }\n    lower.pop();\n    return lower;\n}\n\nfunction _lowerTangent(pointset) {\n    var reversed = pointset.reverse(),\n        upper = [];\n    for (var u = 0; u < reversed.length; u++) {\n        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {\n            upper.pop();\n        }\n        upper.push(reversed[u]);\n    }\n    upper.pop();\n    return upper;\n}\n\n// pointset has to be sorted by X\nfunction convex(pointset) {\n    var convex,\n        upper = _upperTangent(pointset),\n        lower = _lowerTangent(pointset);\n    convex = lower.concat(upper);\n    convex.push(pointset[0]);  \n    return convex;  \n}\n\nmodule.exports = convex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/convex.js\n// module id = 3\n// module chunks = 0 1","module.exports = {\n\n    toXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            var _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');\n            return _getXY(pt);\n        });\n    },\n\n    fromXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            var _getObj = new Function('pt', 'var o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');\n            return _getObj(pt);\n        });\n    }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/format.js\n// module id = 4\n// module chunks = 0 1","function Grid(points, cellSize) {\n    this._cells = [];\n    this._cellSize = cellSize;\n\n    points.forEach(function(point) {\n        var cellXY = this.point2CellXY(point),\n            x = cellXY[0],\n            y = cellXY[1];\n        if (this._cells[x] === undefined) {\n            this._cells[x] = [];\n        }\n        if (this._cells[x][y] === undefined) {\n            this._cells[x][y] = [];\n        }\n        this._cells[x][y].push(point);\n    }, this);\n}\n\nGrid.prototype = {\n    cellPoints: function(x, y) { // (Number, Number) -> Array\n        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];\n    },\n\n    rangePoints: function(bbox) { // (Array) -> Array\n        var tlCellXY = this.point2CellXY([bbox[0], bbox[1]]),\n            brCellXY = this.point2CellXY([bbox[2], bbox[3]]),\n            points = [];\n\n        for (var x = tlCellXY[0]; x <= brCellXY[0]; x++) {\n            for (var y = tlCellXY[1]; y <= brCellXY[1]; y++) {\n                points = points.concat(this.cellPoints(x, y));\n            }\n        }\n\n        return points;\n    },\n\n    removePoint: function(point) { // (Array) -> Array\n        var cellXY = this.point2CellXY(point),\n            cell = this._cells[cellXY[0]][cellXY[1]],\n            pointIdxInCell;\n        \n        for (var i = 0; i < cell.length; i++) {\n            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {\n                pointIdxInCell = i;\n                break;\n            }\n        }\n\n        cell.splice(pointIdxInCell, 1);\n\n        return cell;\n    },\n\n    point2CellXY: function(point) { // (Array) -> Array\n        var x = parseInt(point[0] / this._cellSize),\n            y = parseInt(point[1] / this._cellSize);\n        return [x, y];\n    },\n\n    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array\n        return [\n            bbox[0] - (scaleFactor * this._cellSize),\n            bbox[1] - (scaleFactor * this._cellSize),\n            bbox[2] + (scaleFactor * this._cellSize),\n            bbox[3] + (scaleFactor * this._cellSize)\n        ];\n    }\n};\n\nfunction grid(points, cellSize) {\n    return new Grid(points, cellSize);\n}\n\nmodule.exports = grid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/grid.js\n// module id = 5\n// module chunks = 0 1","/*\n (c) 2014-2016, Andrii Heonia\n Hull.js, a JavaScript library for concave hull generation by set of points.\n https://github.com/AndriiHeonia/hull\n*/\n\n'use strict';\n\nvar intersect = require('./intersect.js');\nvar grid = require('./grid.js');\nvar formatUtil = require('./format.js');\nvar convexHull = require('./convex.js');\n\nfunction _filterDuplicates(pointset) {\n    return pointset.filter(function(el, idx, arr) {\n        var prevEl = arr[idx - 1];\n        return idx === 0 || !(prevEl[0] === el[0] && prevEl[1] === el[1]);\n    });\n}\n\nfunction _sortByX(pointset) {\n    return pointset.sort(function(a, b) {\n        if (a[0] == b[0]) {\n            return a[1] - b[1];\n        } else {\n            return a[0] - b[0];\n        }\n    });\n}\n\nfunction _sqLength(a, b) {\n    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\n\nfunction _cos(o, a, b) {\n    var aShifted = [a[0] - o[0], a[1] - o[1]],\n        bShifted = [b[0] - o[0], b[1] - o[1]],\n        sqALen = _sqLength(o, a),\n        sqBLen = _sqLength(o, b),\n        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n\n    return dot / Math.sqrt(sqALen * sqBLen);\n}\n\nfunction _intersect(segment, pointset) {\n    for (var i = 0; i < pointset.length - 1; i++) {\n        var seg = [pointset[i], pointset[i + 1]];\n        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||\n            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n            continue;\n        }\n        if (intersect(segment, seg)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _occupiedArea(pointset) {\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    for (var i = pointset.length - 1; i >= 0; i--) {\n        if (pointset[i][0] < minX) {\n            minX = pointset[i][0];\n        }\n        if (pointset[i][1] < minY) {\n            minY = pointset[i][1];\n        }\n        if (pointset[i][0] > maxX) {\n            maxX = pointset[i][0];\n        }\n        if (pointset[i][1] > maxY) {\n            maxY = pointset[i][1];\n        }\n    }\n\n    return [\n        maxX - minX, // width\n        maxY - minY  // height\n    ];\n}\n\nfunction _bBoxAround(edge) {\n    return [\n        Math.min(edge[0][0], edge[1][0]), // left\n        Math.min(edge[0][1], edge[1][1]), // top\n        Math.max(edge[0][0], edge[1][0]), // right\n        Math.max(edge[0][1], edge[1][1])  // bottom\n    ];\n}\n\nfunction _midPoint(edge, innerPoints, convex) {\n    var point = null,\n        angle1Cos = MAX_CONCAVE_ANGLE_COS,\n        angle2Cos = MAX_CONCAVE_ANGLE_COS,\n        a1Cos, a2Cos;\n\n    for (var i = 0; i < innerPoints.length; i++) {\n        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n\n        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&\n            !_intersect([edge[0], innerPoints[i]], convex) &&\n            !_intersect([edge[1], innerPoints[i]], convex)) {\n\n            angle1Cos = a1Cos;\n            angle2Cos = a2Cos;\n            point = innerPoints[i];\n        }\n    }\n\n    return point;\n}\n\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n    var edge,\n        keyInSkipList,\n        scaleFactor,\n        midPoint,\n        bBoxAround,\n        bBoxWidth,\n        bBoxHeight,\n        midPointInserted = false;\n\n    for (var i = 0; i < convex.length - 1; i++) {\n        edge = [convex[i], convex[i + 1]];\n        keyInSkipList = edge[0].join() + ',' + edge[1].join();\n\n        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||\n            edgeSkipList[keyInSkipList] === true) { continue; }\n\n        scaleFactor = 0;\n        bBoxAround = _bBoxAround(edge);\n        do {\n            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n\n            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);            \n            scaleFactor++;\n        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n\n        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n            edgeSkipList[keyInSkipList] = true;\n        }\n\n        if (midPoint !== null) {\n            convex.splice(i + 1, 0, midPoint);\n            grid.removePoint(midPoint);\n            midPointInserted = true;\n        }\n    }\n\n    if (midPointInserted) {\n        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n    }\n\n    return convex;\n}\n\nfunction hull(pointset, concavity, format) {\n    var convex,\n        concave,\n        innerPoints,\n        occupiedArea,\n        maxSearchArea,\n        cellSize,\n        points,\n        maxEdgeLen = concavity || 20;\n\n    if (pointset.length < 4) {\n        return pointset.slice();\n    }\n\n    points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n\n    occupiedArea = _occupiedArea(points);\n    maxSearchArea = [\n        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n    ];\n\n    convex = convexHull(points);\n    innerPoints = points.filter(function(pt) {\n        return convex.indexOf(pt) < 0;\n    });\n\n    cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n\n    concave = _concave(\n        convex, Math.pow(maxEdgeLen, 2),\n        maxSearchArea, grid(innerPoints, cellSize), {});\n \n    return formatUtil.fromXy(concave, format);\n}\n\nvar MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nvar MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n\nmodule.exports = hull;\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/hull.js\n// module id = 6\n// module chunks = 0 1","function ccw(x1, y1, x2, y2, x3, y3) {           \n    var cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));\n    return cw > 0 ? true : cw < 0 ? false : true; // colinear\n}\n\nfunction intersect(seg1, seg2) {\n  var x1 = seg1[0][0], y1 = seg1[0][1],\n      x2 = seg1[1][0], y2 = seg1[1][1],\n      x3 = seg2[0][0], y3 = seg2[0][1],\n      x4 = seg2[1][0], y4 = seg2[1][1];\n\n    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n}\n\nmodule.exports = intersect;\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/intersect.js\n// module id = 7\n// module chunks = 0 1"],"sourceRoot":""}