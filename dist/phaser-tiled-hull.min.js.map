{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///phaser-tiled-hull.min.js","webpack:///webpack/bootstrap b9519cf778a62c0a7efb?c233","webpack:///./tiled-hull.js?ab69","webpack:///./index.js?2645","webpack:///./polygon-edge.js?7798","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/convex.js?983f","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/format.js?1322","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/grid.js?e852","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/hull.js?f550","webpack:///E:/Github/phaser-tiled-hull/~/hull.js/src/intersect.js?a9a3"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_toConsumableArray","arr","Array","isArray","arr2","length","from","phaserTiledHull","tilemapLayer","_ref","arguments","undefined","_ref$tileIndices","tileIndices","_ref$tileProperty","tileProperty","_ref$checkCollide","checkCollide","clusters","calculateClusters","pointHulls","calculateHullPoints","polyHulls","buildPolygons","hulls","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","entries","Symbol","iterator","next","done","_ref2","_ref3","_slicedToArray","polyHull","hull","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","edge","push","__WEBPACK_IMPORTED_MODULE_1__polygon_edge__","err","return","checkTile","tile","includes","index","properties","collides","recursivelySearchNeighbors","x","y","cluster","getTile","indexOf","tilemap","map","tx","ty","width","height","searchTile","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","points","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","left","top","right","bottom","__WEBPACK_IMPORTED_MODULE_0_hull_js___default","polygons","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","hullPoints","edges","currentEdge","Phaser","Line","concat","segment","checkIfCollinear","start","end","clone","firstLine","shift","lastLine","pop","combinedLine","line1","line2","dx1","dy1","dx2","__WEBPACK_IMPORTED_MODULE_0_hull_js__","sliceIterator","_arr","_n","_d","_e","_s","_i","TypeError","default","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","PolygonEdge","line","hullIndex","midpoint","midPoint","normal","_getOutwardNormal","shapeId","Point","setMagnitude","_cross","a","b","_upperTangent","pointset","lower","_lowerTangent","reversed","reverse","upper","u","convex","toXy","format","slice","pt","Function","fromXy","Grid","cellSize","_cells","_cellSize","forEach","point","cellXY","point2CellXY","grid","cellPoints","rangePoints","bbox","tlCellXY","brCellXY","removePoint","pointIdxInCell","cell","splice","parseInt","extendBbox","scaleFactor","_filterDuplicates","filter","el","idx","prevEl","_sortByX","sort","_sqLength","Math","pow","_cos","aShifted","bShifted","sqALen","sqBLen","sqrt","_intersect","seg","intersect","_occupiedArea","minX","Infinity","minY","maxX","maxY","_bBoxAround","min","max","_midPoint","innerPoints","a1Cos","a2Cos","angle1Cos","MAX_CONCAVE_ANGLE_COS","angle2Cos","_concave","maxSqEdgeLen","maxSearchArea","edgeSkipList","keyInSkipList","bBoxAround","bBoxWidth","bBoxHeight","midPointInserted","join","concavity","concave","occupiedArea","maxEdgeLen","formatUtil","MAX_SEARCH_BBOX_SIZE_PERCENT","convexHull","ceil","cos","PI","ccw","x1","y1","x2","y2","x3","y3","cw","seg1","seg2","x4","y4"],"mappings":"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","file":"phaser-tiled-hull.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phaserTiledHull\"] = factory();\n\telse\n\t\troot[\"phaserTiledHull\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"phaserTiledHull\"] = factory();\n\telse\n\t\troot[\"phaserTiledHull\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hull_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_hull_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_hull_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polygon_edge__ = __webpack_require__(2);\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n // JS extension required\n\n\n/**\r\n * A function to take a tilemap layer and process its tiles into clusters. This returns an array of\r\n * polygons - each polygon encloses a separate cluster of tiles in the tilemap layer.\r\n *\r\n * @param {Phaser.TilemapLayer} tilemapLayer The tilemap layer to use for hull calculation.\r\n * @param {object} [options = {}] Options for filtering the tiles and only allowing certain tiles to\r\n * be added to the final hulls. If no options specified, then all tiles in the layer will be\r\n * processed and added to a hull. If multiple options are specified, then a tile only has to match\r\n * ONE of the options to be added to a hull.\r\n * @param {number[]} [options.tileIndices = null] An array of tile indices to use for determining\r\n * which tiles should be clustered together. If a tile's index matches an index in the array, it\r\n * will be added to a hull.\r\n * @param {string} [options.tileProperty = null] The name of a property on tiles (set in Tiled) to\r\n * use for determining which tiles should be clustered together. If the property is true (or truthy)\r\n * on a tile, it will be added to a hull.\r\n * @param {boolean} [options.checkCollide = false] Whether or not a tile's collide property should\r\n * be used for determining which tiles should be clustered together. If true, then colliding tiles\r\n * will be added to a hull.\r\n * @returns {Array.<PolygonEdge[]>} An array where each element represents a polygon. The polygons\r\n * are stored as an array of PolygonEdge instances.\r\n */\nfunction phaserTiledHull(tilemapLayer) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$tileIndices = _ref.tileIndices,\n        tileIndices = _ref$tileIndices === undefined ? null : _ref$tileIndices,\n        _ref$tileProperty = _ref.tileProperty,\n        tileProperty = _ref$tileProperty === undefined ? null : _ref$tileProperty,\n        _ref$checkCollide = _ref.checkCollide,\n        checkCollide = _ref$checkCollide === undefined ? false : _ref$checkCollide;\n\n    // Separate the tilemap layer into an array of clustered tiles\n    var clusters = calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide);\n    // Take the clustered tiles and calculate a hull for each cluster\n    var pointHulls = calculateHullPoints(clusters);\n    // Take the point hulls and turn them into polygon representations (i.e. connect the dots)\n    var polyHulls = buildPolygons(pointHulls);\n    // Turn the lines in polyHulls into PolygonEdge instances, pre-caching some helpful info like\n    // the edge normals\n    var hulls = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = polyHulls.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n\n            var _ref3 = _slicedToArray(_ref2, 2);\n\n            var i = _ref3[0];\n            var polyHull = _ref3[1];\n\n            var hull = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = polyHull[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var edge = _step2.value;\n\n                    hull.push(new __WEBPACK_IMPORTED_MODULE_1__polygon_edge__[\"a\" /* default */](edge, i));\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            hulls.push(hull);\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return hulls;\n}\n\nfunction calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide) {\n    var tilemap = tilemapLayer.map;\n    var clusters = [];\n    var getTile = function getTile(tx, ty) {\n        return tilemap.getTile(tx, ty, tilemapLayer.index);\n    };\n\n    // Loop over all tiles in the map and kick off recursive cluster building\n    for (var x = 0; x < tilemap.width; x++) {\n        for (var y = 0; y < tilemap.height; y++) {\n            var tile = getTile(x, y);\n            if (checkTile(tile) && !findTileInClusters(tile)) {\n                var cluster = [];\n                recursivelySearchNeighbors(x, y, cluster);\n                clusters.push(cluster);\n            }\n        }\n    }\n\n    // Check to make sure the tile passes the checks, i.e. it is allowed to be in a cluster\n    function checkTile(tile) {\n        // No tile, ignore\n        if (!tile) return false;\n        // If an array of indices was provided, tile's index must be in that array\n        if (tileIndices && tileIndices.includes(tile.index)) return true;\n        // If a tile property was provided, the tile must have a truthy value for that property\n        if (tileProperty && tile.properties[tileProperty]) return true;\n        // If we only care about colliding tiles, make sure the tile collides\n        if (checkCollide && tile.collides) return true;\n        // Tile didn't pass any checks, ignore\n        return false;\n    }\n\n    function recursivelySearchNeighbors(x, y, cluster) {\n        // If tile passes the checks and is not already in the cluster, add it and recursively check\n        // the neighbors. Note: There's no chance of a tile being a member of two separate clusters.\n        var tile = getTile(x, y);\n        if (checkTile(tile) && cluster.indexOf(tile) === -1) {\n            cluster.push(tile); // Add the current tile\n            // Search the neighbors\n            recursivelySearchNeighbors(x, y - 1, cluster);\n            recursivelySearchNeighbors(x, y + 1, cluster);\n            recursivelySearchNeighbors(x + 1, y, cluster);\n            recursivelySearchNeighbors(x - 1, y, cluster);\n        }\n    }\n\n    function findTileInClusters(searchTile) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n            for (var _iterator3 = clusters[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var _cluster = _step3.value;\n                var _iteratorNormalCompletion4 = true;\n                var _didIteratorError4 = false;\n                var _iteratorError4 = undefined;\n\n                try {\n                    for (var _iterator4 = _cluster[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var _tile = _step4.value;\n\n                        if (searchTile === _tile) return _cluster;\n                    }\n                } catch (err) {\n                    _didIteratorError4 = true;\n                    _iteratorError4 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                            _iterator4.return();\n                        }\n                    } finally {\n                        if (_didIteratorError4) {\n                            throw _iteratorError4;\n                        }\n                    }\n                }\n            }\n        } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                    _iterator3.return();\n                }\n            } finally {\n                if (_didIteratorError3) {\n                    throw _iteratorError3;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    return clusters;\n}\n\nfunction calculateHullPoints(clusters) {\n    var hulls = [];\n\n    // Loop over each cluster of tiles in clusters and calculate a polygon hull\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n        for (var _iterator5 = clusters[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var cluster = _step5.value;\n\n            // Find all the points - i.e. the corners of each tile in the cluster\n            var points = [];\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = cluster[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var tile = _step6.value;\n\n                    points.push([tile.left, tile.top], [tile.right, tile.top], [tile.left, tile.bottom], [tile.right, tile.bottom]);\n                }\n\n                // Use hull.js to find a hull (e.g. points in clockwise order). The second parameter is the \n                // concavity of the hull, with 1 being maximally concave.  \n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            var hull = __WEBPACK_IMPORTED_MODULE_0_hull_js___default()(points, 1);\n            hulls.push(hull);\n        }\n    } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                _iterator5.return();\n            }\n        } finally {\n            if (_didIteratorError5) {\n                throw _iteratorError5;\n            }\n        }\n    }\n\n    return hulls;\n}\n\nfunction buildPolygons(hulls) {\n    var polygons = [];\n\n    var _iteratorNormalCompletion7 = true;\n    var _didIteratorError7 = false;\n    var _iteratorError7 = undefined;\n\n    try {\n        for (var _iterator7 = hulls[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var hullPoints = _step7.value;\n\n            var edges = [];\n\n            // Walk along the line segments of the hull, collapsing collinear lines into a single edge\n            var currentEdge = new (Function.prototype.bind.apply(Phaser.Line, [null].concat(_toConsumableArray(hullPoints[0]), _toConsumableArray(hullPoints[1]))))();\n            var segment = void 0;\n            for (var i = 1; i < hullPoints.length; i++) {\n                // Get the next line segment - starts from the endpoint of the last segment\n                segment = new (Function.prototype.bind.apply(Phaser.Line, [null].concat(_toConsumableArray(hullPoints[i - 1]), _toConsumableArray(hullPoints[i]))))();\n\n                if (checkIfCollinear(currentEdge, segment)) {\n                    // If the current edge and line segment are collinear, then we haven't reached the\n                    // end of the edge yet. Extend the edge to contain the segment.\n                    currentEdge = new Phaser.Line(currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y);\n                } else {\n                    // We've reached a corner, so the edge is done. Save it and start a new one.\n                    edges.push(currentEdge);\n                    currentEdge = segment.clone();\n                }\n            }\n\n            // Process the last line segment - connecting the last point back around to the first point\n            segment = new (Function.prototype.bind.apply(Phaser.Line, [null].concat(_toConsumableArray(hullPoints[hullPoints.length - 1]), _toConsumableArray(hullPoints[0]))))();\n            if (checkIfCollinear(currentEdge, segment)) {\n                // Extend the edge and add it (since it wasn't added by the loop above)\n                currentEdge = new Phaser.Line(currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y);\n                edges.push(currentEdge);\n            } else {\n                // Corner - add the edge and the next segment \n                edges.push(currentEdge);\n                edges.push(segment);\n            }\n\n            // Determine whether the last edge and the first edge need to be merged (if the points in\n            // the hull started midway through an edge)\n            if (checkIfCollinear(edges[0], edges[edges.length - 1])) {\n                var firstLine = edges.shift();\n                var lastLine = edges.pop();\n                var combinedLine = new Phaser.Line(firstLine.start.x, firstLine.start.y, lastLine.end.x, lastLine.end.y);\n                edges.push(combinedLine);\n            }\n\n            // Add the final lines to the polygon\n            polygons.push(edges);\n        }\n    } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                _iterator7.return();\n            }\n        } finally {\n            if (_didIteratorError7) {\n                throw _iteratorError7;\n            }\n        }\n    }\n\n    return polygons;\n}\n\nfunction checkIfCollinear(line1, line2) {\n    // To check if two slopes are equal:\n    //  lineDeltaY / lineDeltaX = segmentDeltaY / segmentDeltaX\n    // But to avoid dividing by zero:\n    //  (lineDeltaX * segmentDeltaY) - (lineDeltaY * segmentDeltaX) = 0\n    var dx1 = line1.end.x - line1.start.x;\n    var dy1 = line1.end.y - line1.start.y;\n    var dx2 = line2.end.x - line2.start.x;\n    var dy2 = line2.end.y - line2.start.y;\n    return dx1 * dy2 - dy1 * dx2 === 0;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (phaserTiledHull);\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\n// up with something having to do \"phaserTiledHull.default(...)\" instead of \"phaserTiledHull(...)\"\nmodule.exports = __webpack_require__(0).default;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Small class for precomuting some useful information about an edge of a polygon - the line,\r\n * length, midpoint, normal\r\n *\r\n * @class PolygonEdge\r\n */\nvar PolygonEdge = function () {\n  function PolygonEdge(line, hullIndex) {\n    _classCallCheck(this, PolygonEdge);\n\n    /**\r\n     * The line that makes up the edge\r\n     * @type {Phaser.Line}\r\n     */\n    this.line = line;\n\n    /** @type {number} */\n    this.length = line.length;\n\n    /** @type {Phaser.Point} */\n    this.midpoint = line.midPoint();\n\n    /** \r\n     * Outward-facing normal vector as a point, normalized to unit length\r\n     * @type {Phaser.Point} \r\n     * */\n    this.normal = this._getOutwardNormal(line);\n\n    /**\r\n     * Identifies which hull index this edge is a part of \r\n     * @type {number} \r\n     * */\n    this.shapeId = hullIndex;\n  }\n\n  _createClass(PolygonEdge, [{\n    key: \"_getOutwardNormal\",\n    value: function _getOutwardNormal(line) {\n      // The wall lines are returned from hull.js in clockwise order, so the outward facing normal\n      // is the following\n      return new Phaser.Point(line.end.y - line.start.y, -(line.end.x - line.start.x)).setMagnitude(1);\n    }\n  }]);\n\n  return PolygonEdge;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PolygonEdge);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nfunction _cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\nfunction _upperTangent(pointset) {\n    var lower = [];\n    for (var l = 0; l < pointset.length; l++) {\n        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {\n            lower.pop();\n        }\n        lower.push(pointset[l]);\n    }\n    lower.pop();\n    return lower;\n}\n\nfunction _lowerTangent(pointset) {\n    var reversed = pointset.reverse(),\n        upper = [];\n    for (var u = 0; u < reversed.length; u++) {\n        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {\n            upper.pop();\n        }\n        upper.push(reversed[u]);\n    }\n    upper.pop();\n    return upper;\n}\n\n// pointset has to be sorted by X\nfunction convex(pointset) {\n    var convex,\n        upper = _upperTangent(pointset),\n        lower = _lowerTangent(pointset);\n    convex = lower.concat(upper);\n    convex.push(pointset[0]);  \n    return convex;  \n}\n\nmodule.exports = convex;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n\n    toXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            var _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');\n            return _getXY(pt);\n        });\n    },\n\n    fromXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            var _getObj = new Function('pt', 'var o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');\n            return _getObj(pt);\n        });\n    }\n\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nfunction Grid(points, cellSize) {\n    this._cells = [];\n    this._cellSize = cellSize;\n\n    points.forEach(function(point) {\n        var cellXY = this.point2CellXY(point),\n            x = cellXY[0],\n            y = cellXY[1];\n        if (this._cells[x] === undefined) {\n            this._cells[x] = [];\n        }\n        if (this._cells[x][y] === undefined) {\n            this._cells[x][y] = [];\n        }\n        this._cells[x][y].push(point);\n    }, this);\n}\n\nGrid.prototype = {\n    cellPoints: function(x, y) { // (Number, Number) -> Array\n        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];\n    },\n\n    rangePoints: function(bbox) { // (Array) -> Array\n        var tlCellXY = this.point2CellXY([bbox[0], bbox[1]]),\n            brCellXY = this.point2CellXY([bbox[2], bbox[3]]),\n            points = [];\n\n        for (var x = tlCellXY[0]; x <= brCellXY[0]; x++) {\n            for (var y = tlCellXY[1]; y <= brCellXY[1]; y++) {\n                points = points.concat(this.cellPoints(x, y));\n            }\n        }\n\n        return points;\n    },\n\n    removePoint: function(point) { // (Array) -> Array\n        var cellXY = this.point2CellXY(point),\n            cell = this._cells[cellXY[0]][cellXY[1]],\n            pointIdxInCell;\n        \n        for (var i = 0; i < cell.length; i++) {\n            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {\n                pointIdxInCell = i;\n                break;\n            }\n        }\n\n        cell.splice(pointIdxInCell, 1);\n\n        return cell;\n    },\n\n    point2CellXY: function(point) { // (Array) -> Array\n        var x = parseInt(point[0] / this._cellSize),\n            y = parseInt(point[1] / this._cellSize);\n        return [x, y];\n    },\n\n    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array\n        return [\n            bbox[0] - (scaleFactor * this._cellSize),\n            bbox[1] - (scaleFactor * this._cellSize),\n            bbox[2] + (scaleFactor * this._cellSize),\n            bbox[3] + (scaleFactor * this._cellSize)\n        ];\n    }\n};\n\nfunction grid(points, cellSize) {\n    return new Grid(points, cellSize);\n}\n\nmodule.exports = grid;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n (c) 2014-2016, Andrii Heonia\n Hull.js, a JavaScript library for concave hull generation by set of points.\n https://github.com/AndriiHeonia/hull\n*/\n\n\n\nvar intersect = __webpack_require__(7);\nvar grid = __webpack_require__(5);\nvar formatUtil = __webpack_require__(4);\nvar convexHull = __webpack_require__(3);\n\nfunction _filterDuplicates(pointset) {\n    return pointset.filter(function(el, idx, arr) {\n        var prevEl = arr[idx - 1];\n        return idx === 0 || !(prevEl[0] === el[0] && prevEl[1] === el[1]);\n    });\n}\n\nfunction _sortByX(pointset) {\n    return pointset.sort(function(a, b) {\n        if (a[0] == b[0]) {\n            return a[1] - b[1];\n        } else {\n            return a[0] - b[0];\n        }\n    });\n}\n\nfunction _sqLength(a, b) {\n    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\n\nfunction _cos(o, a, b) {\n    var aShifted = [a[0] - o[0], a[1] - o[1]],\n        bShifted = [b[0] - o[0], b[1] - o[1]],\n        sqALen = _sqLength(o, a),\n        sqBLen = _sqLength(o, b),\n        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n\n    return dot / Math.sqrt(sqALen * sqBLen);\n}\n\nfunction _intersect(segment, pointset) {\n    for (var i = 0; i < pointset.length - 1; i++) {\n        var seg = [pointset[i], pointset[i + 1]];\n        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||\n            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n            continue;\n        }\n        if (intersect(segment, seg)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _occupiedArea(pointset) {\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    for (var i = pointset.length - 1; i >= 0; i--) {\n        if (pointset[i][0] < minX) {\n            minX = pointset[i][0];\n        }\n        if (pointset[i][1] < minY) {\n            minY = pointset[i][1];\n        }\n        if (pointset[i][0] > maxX) {\n            maxX = pointset[i][0];\n        }\n        if (pointset[i][1] > maxY) {\n            maxY = pointset[i][1];\n        }\n    }\n\n    return [\n        maxX - minX, // width\n        maxY - minY  // height\n    ];\n}\n\nfunction _bBoxAround(edge) {\n    return [\n        Math.min(edge[0][0], edge[1][0]), // left\n        Math.min(edge[0][1], edge[1][1]), // top\n        Math.max(edge[0][0], edge[1][0]), // right\n        Math.max(edge[0][1], edge[1][1])  // bottom\n    ];\n}\n\nfunction _midPoint(edge, innerPoints, convex) {\n    var point = null,\n        angle1Cos = MAX_CONCAVE_ANGLE_COS,\n        angle2Cos = MAX_CONCAVE_ANGLE_COS,\n        a1Cos, a2Cos;\n\n    for (var i = 0; i < innerPoints.length; i++) {\n        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n\n        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&\n            !_intersect([edge[0], innerPoints[i]], convex) &&\n            !_intersect([edge[1], innerPoints[i]], convex)) {\n\n            angle1Cos = a1Cos;\n            angle2Cos = a2Cos;\n            point = innerPoints[i];\n        }\n    }\n\n    return point;\n}\n\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n    var edge,\n        keyInSkipList,\n        scaleFactor,\n        midPoint,\n        bBoxAround,\n        bBoxWidth,\n        bBoxHeight,\n        midPointInserted = false;\n\n    for (var i = 0; i < convex.length - 1; i++) {\n        edge = [convex[i], convex[i + 1]];\n        keyInSkipList = edge[0].join() + ',' + edge[1].join();\n\n        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||\n            edgeSkipList[keyInSkipList] === true) { continue; }\n\n        scaleFactor = 0;\n        bBoxAround = _bBoxAround(edge);\n        do {\n            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n\n            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);            \n            scaleFactor++;\n        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n\n        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n            edgeSkipList[keyInSkipList] = true;\n        }\n\n        if (midPoint !== null) {\n            convex.splice(i + 1, 0, midPoint);\n            grid.removePoint(midPoint);\n            midPointInserted = true;\n        }\n    }\n\n    if (midPointInserted) {\n        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n    }\n\n    return convex;\n}\n\nfunction hull(pointset, concavity, format) {\n    var convex,\n        concave,\n        innerPoints,\n        occupiedArea,\n        maxSearchArea,\n        cellSize,\n        points,\n        maxEdgeLen = concavity || 20;\n\n    if (pointset.length < 4) {\n        return pointset.slice();\n    }\n\n    points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n\n    occupiedArea = _occupiedArea(points);\n    maxSearchArea = [\n        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n    ];\n\n    convex = convexHull(points);\n    innerPoints = points.filter(function(pt) {\n        return convex.indexOf(pt) < 0;\n    });\n\n    cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n\n    concave = _concave(\n        convex, Math.pow(maxEdgeLen, 2),\n        maxSearchArea, grid(innerPoints, cellSize), {});\n \n    return formatUtil.fromXy(concave, format);\n}\n\nvar MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nvar MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n\nmodule.exports = hull;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nfunction ccw(x1, y1, x2, y2, x3, y3) {           \n    var cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));\n    return cw > 0 ? true : cw < 0 ? false : true; // colinear\n}\n\nfunction intersect(seg1, seg2) {\n  var x1 = seg1[0][0], y1 = seg1[0][1],\n      x2 = seg1[1][0], y2 = seg1[1][1],\n      x3 = seg2[0][0], y3 = seg2[0][1],\n      x4 = seg2[1][0], y4 = seg2[1][1];\n\n    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n}\n\nmodule.exports = intersect;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// phaser-tiled-hull.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b9519cf778a62c0a7efb","import hulljs from \"hull.js\"; // JS extension required\r\nimport PolygonEdge from \"./polygon-edge\";\r\n\r\n/**\r\n * A function to take a tilemap layer and process its tiles into clusters. This returns an array of\r\n * polygons - each polygon encloses a separate cluster of tiles in the tilemap layer.\r\n *\r\n * @param {Phaser.TilemapLayer} tilemapLayer The tilemap layer to use for hull calculation.\r\n * @param {object} [options = {}] Options for filtering the tiles and only allowing certain tiles to\r\n * be added to the final hulls. If no options specified, then all tiles in the layer will be\r\n * processed and added to a hull. If multiple options are specified, then a tile only has to match\r\n * ONE of the options to be added to a hull.\r\n * @param {number[]} [options.tileIndices = null] An array of tile indices to use for determining\r\n * which tiles should be clustered together. If a tile's index matches an index in the array, it\r\n * will be added to a hull.\r\n * @param {string} [options.tileProperty = null] The name of a property on tiles (set in Tiled) to\r\n * use for determining which tiles should be clustered together. If the property is true (or truthy)\r\n * on a tile, it will be added to a hull.\r\n * @param {boolean} [options.checkCollide = false] Whether or not a tile's collide property should\r\n * be used for determining which tiles should be clustered together. If true, then colliding tiles\r\n * will be added to a hull.\r\n * @returns {Array.<PolygonEdge[]>} An array where each element represents a polygon. The polygons\r\n * are stored as an array of PolygonEdge instances.\r\n */\r\nfunction phaserTiledHull(tilemapLayer, {tileIndices = null, tileProperty = null, \r\n        checkCollide = false} = {}) {\r\n    // Separate the tilemap layer into an array of clustered tiles\r\n    const clusters = calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide);\r\n    // Take the clustered tiles and calculate a hull for each cluster\r\n    const pointHulls = calculateHullPoints(clusters);\r\n    // Take the point hulls and turn them into polygon representations (i.e. connect the dots)\r\n    const polyHulls = buildPolygons(pointHulls);\r\n    // Turn the lines in polyHulls into PolygonEdge instances, pre-caching some helpful info like\r\n    // the edge normals\r\n    const hulls = [];\r\n    for (const [i, polyHull] of polyHulls.entries()) {\r\n        const hull = [];\r\n        for (const edge of polyHull) {\r\n            hull.push(new PolygonEdge(edge, i));\r\n        }\r\n        hulls.push(hull);\r\n    }\r\n    return hulls;\r\n}\r\n\r\nfunction calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide) {\r\n    const tilemap = tilemapLayer.map;\r\n    const clusters = [];\r\n    const getTile = (tx, ty) => tilemap.getTile(tx, ty, tilemapLayer.index);\r\n    \r\n    // Loop over all tiles in the map and kick off recursive cluster building\r\n    for (var x = 0; x < tilemap.width; x++) {\r\n        for (var y = 0; y < tilemap.height; y++) {\r\n            const tile = getTile(x, y);\r\n            if (checkTile(tile) && !findTileInClusters(tile)) {\r\n                const cluster = [];\r\n                recursivelySearchNeighbors(x, y, cluster);\r\n                clusters.push(cluster);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Check to make sure the tile passes the checks, i.e. it is allowed to be in a cluster\r\n    function checkTile(tile) {\r\n        // No tile, ignore\r\n        if (!tile) return false;\r\n        // If an array of indices was provided, tile's index must be in that array\r\n        if (tileIndices && tileIndices.includes(tile.index)) return true;\r\n        // If a tile property was provided, the tile must have a truthy value for that property\r\n        if (tileProperty && tile.properties[tileProperty]) return true;\r\n        // If we only care about colliding tiles, make sure the tile collides\r\n        if (checkCollide && tile.collides) return true;\r\n        // Tile didn't pass any checks, ignore\r\n        return false;\r\n    }\r\n\r\n    function recursivelySearchNeighbors(x, y, cluster) {\r\n        // If tile passes the checks and is not already in the cluster, add it and recursively check\r\n        // the neighbors. Note: There's no chance of a tile being a member of two separate clusters.\r\n        const tile = getTile(x, y);\r\n        if (checkTile(tile) && (cluster.indexOf(tile) === -1)) {\r\n            cluster.push(tile); // Add the current tile\r\n            // Search the neighbors\r\n            recursivelySearchNeighbors(x, y - 1, cluster);\r\n            recursivelySearchNeighbors(x, y + 1, cluster);\r\n            recursivelySearchNeighbors(x + 1, y, cluster);\r\n            recursivelySearchNeighbors(x - 1, y, cluster);\r\n        }\r\n    }\r\n\r\n    function findTileInClusters(searchTile) {\r\n        for (const cluster of clusters) {\r\n            for (const tile of cluster) {\r\n                if (searchTile === tile) return cluster;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    return clusters;\r\n}\r\n\r\nfunction calculateHullPoints(clusters) {\r\n    const hulls = [];\r\n\r\n    // Loop over each cluster of tiles in clusters and calculate a polygon hull\r\n    for (const cluster of clusters) {\r\n        // Find all the points - i.e. the corners of each tile in the cluster\r\n        const points = [];\r\n        for (const tile of cluster) {\r\n            points.push(\r\n                [tile.left, tile.top],\r\n                [tile.right, tile.top],                \r\n                [tile.left, tile.bottom],                \r\n                [tile.right, tile.bottom]\r\n            );\r\n        }\r\n\r\n        // Use hull.js to find a hull (e.g. points in clockwise order). The second parameter is the \r\n        // concavity of the hull, with 1 being maximally concave.  \r\n        const hull = hulljs(points, 1);\r\n        hulls.push(hull);\r\n    }\r\n\r\n    return hulls;\r\n}\r\n\r\nfunction buildPolygons(hulls) {\r\n    const polygons = [];\r\n\r\n    for (const hullPoints of hulls) {\r\n        const edges = [];\r\n\r\n        // Walk along the line segments of the hull, collapsing collinear lines into a single edge\r\n        let currentEdge = new Phaser.Line(...hullPoints[0], ...hullPoints[1]);\r\n        let segment;\r\n        for (let i = 1; i < hullPoints.length; i++) {\r\n            // Get the next line segment - starts from the endpoint of the last segment\r\n            segment = new Phaser.Line(...hullPoints[i - 1], ...hullPoints[i]);\r\n\r\n            if (checkIfCollinear(currentEdge, segment)) {\r\n                // If the current edge and line segment are collinear, then we haven't reached the\r\n                // end of the edge yet. Extend the edge to contain the segment.\r\n                currentEdge = new Phaser.Line(\r\n                    currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y\r\n                );\r\n            } else {\r\n                // We've reached a corner, so the edge is done. Save it and start a new one.\r\n                edges.push(currentEdge);\r\n                currentEdge = segment.clone();             \r\n            }\r\n        }\r\n\r\n        // Process the last line segment - connecting the last point back around to the first point\r\n        segment = new Phaser.Line(...hullPoints[hullPoints.length - 1], ...hullPoints[0]);\r\n        if (checkIfCollinear(currentEdge, segment)) {\r\n            // Extend the edge and add it (since it wasn't added by the loop above)\r\n            currentEdge = new Phaser.Line(\r\n                currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y\r\n            );\r\n            edges.push(currentEdge);\r\n        } else {\r\n            // Corner - add the edge and the next segment \r\n            edges.push(currentEdge);\r\n            edges.push(segment);\r\n        }\r\n\r\n        // Determine whether the last edge and the first edge need to be merged (if the points in\r\n        // the hull started midway through an edge)\r\n        if (checkIfCollinear(edges[0], edges[edges.length - 1])) {\r\n            const firstLine = edges.shift();\r\n            const lastLine = edges.pop();\r\n            var combinedLine = new Phaser.Line(\r\n                firstLine.start.x, firstLine.start.y, lastLine.end.x, lastLine.end.y\r\n            );\r\n            edges.push(combinedLine);\r\n        }\r\n\r\n        // Add the final lines to the polygon\r\n        polygons.push(edges);\r\n    }\r\n    \r\n    return polygons;\r\n}\r\n\r\nfunction checkIfCollinear(line1, line2) {\r\n    // To check if two slopes are equal:\r\n    //  lineDeltaY / lineDeltaX = segmentDeltaY / segmentDeltaX\r\n    // But to avoid dividing by zero:\r\n    //  (lineDeltaX * segmentDeltaY) - (lineDeltaY * segmentDeltaX) = 0\r\n    const dx1 = line1.end.x - line1.start.x;\r\n    const dy1 = line1.end.y - line1.start.y;\r\n    const dx2 = line2.end.x - line2.start.x;\r\n    const dy2 = line2.end.y - line2.start.y;\r\n    return ((dx1 * dy2) - (dy1 * dx2)) === 0;\r\n}\r\n\r\nexport default phaserTiledHull;\n\n\n// WEBPACK FOOTER //\n// ./tiled-hull.js","// Fix for webpack not exporting ES6 module default properly when using global mode of UMD. It ends\r\n// up with something having to do \"phaserTiledHull.default(...)\" instead of \"phaserTiledHull(...)\"\r\nmodule.exports = require(\"./tiled-hull\").default;\n\n\n// WEBPACK FOOTER //\n// ./index.js","/**\r\n * Small class for precomuting some useful information about an edge of a polygon - the line,\r\n * length, midpoint, normal\r\n *\r\n * @class PolygonEdge\r\n */\r\nclass PolygonEdge {\r\n    constructor(line, hullIndex) {\r\n        /**\r\n         * The line that makes up the edge\r\n         * @type {Phaser.Line}\r\n         */\r\n        this.line = line;\r\n\r\n        /** @type {number} */\r\n        this.length = line.length;\r\n\r\n        /** @type {Phaser.Point} */\r\n        this.midpoint = line.midPoint();\r\n        \r\n        /** \r\n         * Outward-facing normal vector as a point, normalized to unit length\r\n         * @type {Phaser.Point} \r\n         * */\r\n        this.normal = this._getOutwardNormal(line);\r\n\r\n        /**\r\n         * Identifies which hull index this edge is a part of \r\n         * @type {number} \r\n         * */\r\n        this.shapeId = hullIndex;\r\n    }\r\n\r\n    _getOutwardNormal(line) {\r\n        // The wall lines are returned from hull.js in clockwise order, so the outward facing normal\r\n        // is the following\r\n        return new Phaser.Point((line.end.y - line.start.y), -(line.end.x - line.start.x))\r\n            .setMagnitude(1);\r\n    }\r\n}\r\n\r\nexport default PolygonEdge;\n\n\n// WEBPACK FOOTER //\n// ./polygon-edge.js","function _cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\nfunction _upperTangent(pointset) {\n    var lower = [];\n    for (var l = 0; l < pointset.length; l++) {\n        while (lower.length >= 2 && (_cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0)) {\n            lower.pop();\n        }\n        lower.push(pointset[l]);\n    }\n    lower.pop();\n    return lower;\n}\n\nfunction _lowerTangent(pointset) {\n    var reversed = pointset.reverse(),\n        upper = [];\n    for (var u = 0; u < reversed.length; u++) {\n        while (upper.length >= 2 && (_cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0)) {\n            upper.pop();\n        }\n        upper.push(reversed[u]);\n    }\n    upper.pop();\n    return upper;\n}\n\n// pointset has to be sorted by X\nfunction convex(pointset) {\n    var convex,\n        upper = _upperTangent(pointset),\n        lower = _lowerTangent(pointset);\n    convex = lower.concat(upper);\n    convex.push(pointset[0]);  \n    return convex;  \n}\n\nmodule.exports = convex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/convex.js\n// module id = 3\n// module chunks = 0 1","module.exports = {\n\n    toXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            var _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');\n            return _getXY(pt);\n        });\n    },\n\n    fromXy: function(pointset, format) {\n        if (format === undefined) {\n            return pointset.slice();\n        }\n        return pointset.map(function(pt) {\n            /*jslint evil: true */\n            var _getObj = new Function('pt', 'var o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');\n            return _getObj(pt);\n        });\n    }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/format.js\n// module id = 4\n// module chunks = 0 1","function Grid(points, cellSize) {\n    this._cells = [];\n    this._cellSize = cellSize;\n\n    points.forEach(function(point) {\n        var cellXY = this.point2CellXY(point),\n            x = cellXY[0],\n            y = cellXY[1];\n        if (this._cells[x] === undefined) {\n            this._cells[x] = [];\n        }\n        if (this._cells[x][y] === undefined) {\n            this._cells[x][y] = [];\n        }\n        this._cells[x][y].push(point);\n    }, this);\n}\n\nGrid.prototype = {\n    cellPoints: function(x, y) { // (Number, Number) -> Array\n        return (this._cells[x] !== undefined && this._cells[x][y] !== undefined) ? this._cells[x][y] : [];\n    },\n\n    rangePoints: function(bbox) { // (Array) -> Array\n        var tlCellXY = this.point2CellXY([bbox[0], bbox[1]]),\n            brCellXY = this.point2CellXY([bbox[2], bbox[3]]),\n            points = [];\n\n        for (var x = tlCellXY[0]; x <= brCellXY[0]; x++) {\n            for (var y = tlCellXY[1]; y <= brCellXY[1]; y++) {\n                points = points.concat(this.cellPoints(x, y));\n            }\n        }\n\n        return points;\n    },\n\n    removePoint: function(point) { // (Array) -> Array\n        var cellXY = this.point2CellXY(point),\n            cell = this._cells[cellXY[0]][cellXY[1]],\n            pointIdxInCell;\n        \n        for (var i = 0; i < cell.length; i++) {\n            if (cell[i][0] === point[0] && cell[i][1] === point[1]) {\n                pointIdxInCell = i;\n                break;\n            }\n        }\n\n        cell.splice(pointIdxInCell, 1);\n\n        return cell;\n    },\n\n    point2CellXY: function(point) { // (Array) -> Array\n        var x = parseInt(point[0] / this._cellSize),\n            y = parseInt(point[1] / this._cellSize);\n        return [x, y];\n    },\n\n    extendBbox: function(bbox, scaleFactor) { // (Array, Number) -> Array\n        return [\n            bbox[0] - (scaleFactor * this._cellSize),\n            bbox[1] - (scaleFactor * this._cellSize),\n            bbox[2] + (scaleFactor * this._cellSize),\n            bbox[3] + (scaleFactor * this._cellSize)\n        ];\n    }\n};\n\nfunction grid(points, cellSize) {\n    return new Grid(points, cellSize);\n}\n\nmodule.exports = grid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/grid.js\n// module id = 5\n// module chunks = 0 1","/*\n (c) 2014-2016, Andrii Heonia\n Hull.js, a JavaScript library for concave hull generation by set of points.\n https://github.com/AndriiHeonia/hull\n*/\n\n'use strict';\n\nvar intersect = require('./intersect.js');\nvar grid = require('./grid.js');\nvar formatUtil = require('./format.js');\nvar convexHull = require('./convex.js');\n\nfunction _filterDuplicates(pointset) {\n    return pointset.filter(function(el, idx, arr) {\n        var prevEl = arr[idx - 1];\n        return idx === 0 || !(prevEl[0] === el[0] && prevEl[1] === el[1]);\n    });\n}\n\nfunction _sortByX(pointset) {\n    return pointset.sort(function(a, b) {\n        if (a[0] == b[0]) {\n            return a[1] - b[1];\n        } else {\n            return a[0] - b[0];\n        }\n    });\n}\n\nfunction _sqLength(a, b) {\n    return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);\n}\n\nfunction _cos(o, a, b) {\n    var aShifted = [a[0] - o[0], a[1] - o[1]],\n        bShifted = [b[0] - o[0], b[1] - o[1]],\n        sqALen = _sqLength(o, a),\n        sqBLen = _sqLength(o, b),\n        dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];\n\n    return dot / Math.sqrt(sqALen * sqBLen);\n}\n\nfunction _intersect(segment, pointset) {\n    for (var i = 0; i < pointset.length - 1; i++) {\n        var seg = [pointset[i], pointset[i + 1]];\n        if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] ||\n            segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {\n            continue;\n        }\n        if (intersect(segment, seg)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _occupiedArea(pointset) {\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    for (var i = pointset.length - 1; i >= 0; i--) {\n        if (pointset[i][0] < minX) {\n            minX = pointset[i][0];\n        }\n        if (pointset[i][1] < minY) {\n            minY = pointset[i][1];\n        }\n        if (pointset[i][0] > maxX) {\n            maxX = pointset[i][0];\n        }\n        if (pointset[i][1] > maxY) {\n            maxY = pointset[i][1];\n        }\n    }\n\n    return [\n        maxX - minX, // width\n        maxY - minY  // height\n    ];\n}\n\nfunction _bBoxAround(edge) {\n    return [\n        Math.min(edge[0][0], edge[1][0]), // left\n        Math.min(edge[0][1], edge[1][1]), // top\n        Math.max(edge[0][0], edge[1][0]), // right\n        Math.max(edge[0][1], edge[1][1])  // bottom\n    ];\n}\n\nfunction _midPoint(edge, innerPoints, convex) {\n    var point = null,\n        angle1Cos = MAX_CONCAVE_ANGLE_COS,\n        angle2Cos = MAX_CONCAVE_ANGLE_COS,\n        a1Cos, a2Cos;\n\n    for (var i = 0; i < innerPoints.length; i++) {\n        a1Cos = _cos(edge[0], edge[1], innerPoints[i]);\n        a2Cos = _cos(edge[1], edge[0], innerPoints[i]);\n\n        if (a1Cos > angle1Cos && a2Cos > angle2Cos &&\n            !_intersect([edge[0], innerPoints[i]], convex) &&\n            !_intersect([edge[1], innerPoints[i]], convex)) {\n\n            angle1Cos = a1Cos;\n            angle2Cos = a2Cos;\n            point = innerPoints[i];\n        }\n    }\n\n    return point;\n}\n\nfunction _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {\n    var edge,\n        keyInSkipList,\n        scaleFactor,\n        midPoint,\n        bBoxAround,\n        bBoxWidth,\n        bBoxHeight,\n        midPointInserted = false;\n\n    for (var i = 0; i < convex.length - 1; i++) {\n        edge = [convex[i], convex[i + 1]];\n        keyInSkipList = edge[0].join() + ',' + edge[1].join();\n\n        if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen ||\n            edgeSkipList[keyInSkipList] === true) { continue; }\n\n        scaleFactor = 0;\n        bBoxAround = _bBoxAround(edge);\n        do {\n            bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);\n            bBoxWidth = bBoxAround[2] - bBoxAround[0];\n            bBoxHeight = bBoxAround[3] - bBoxAround[1];\n\n            midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);            \n            scaleFactor++;\n        }  while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));\n\n        if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {\n            edgeSkipList[keyInSkipList] = true;\n        }\n\n        if (midPoint !== null) {\n            convex.splice(i + 1, 0, midPoint);\n            grid.removePoint(midPoint);\n            midPointInserted = true;\n        }\n    }\n\n    if (midPointInserted) {\n        return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);\n    }\n\n    return convex;\n}\n\nfunction hull(pointset, concavity, format) {\n    var convex,\n        concave,\n        innerPoints,\n        occupiedArea,\n        maxSearchArea,\n        cellSize,\n        points,\n        maxEdgeLen = concavity || 20;\n\n    if (pointset.length < 4) {\n        return pointset.slice();\n    }\n\n    points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));\n\n    occupiedArea = _occupiedArea(points);\n    maxSearchArea = [\n        occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,\n        occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT\n    ];\n\n    convex = convexHull(points);\n    innerPoints = points.filter(function(pt) {\n        return convex.indexOf(pt) < 0;\n    });\n\n    cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));\n\n    concave = _concave(\n        convex, Math.pow(maxEdgeLen, 2),\n        maxSearchArea, grid(innerPoints, cellSize), {});\n \n    return formatUtil.fromXy(concave, format);\n}\n\nvar MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg\nvar MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;\n\nmodule.exports = hull;\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/hull.js\n// module id = 6\n// module chunks = 0 1","function ccw(x1, y1, x2, y2, x3, y3) {           \n    var cw = ((y3 - y1) * (x2 - x1)) - ((y2 - y1) * (x3 - x1));\n    return cw > 0 ? true : cw < 0 ? false : true; // colinear\n}\n\nfunction intersect(seg1, seg2) {\n  var x1 = seg1[0][0], y1 = seg1[0][1],\n      x2 = seg1[1][0], y2 = seg1[1][1],\n      x3 = seg2[0][0], y3 = seg2[0][1],\n      x4 = seg2[1][0], y4 = seg2[1][1];\n\n    return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);\n}\n\nmodule.exports = intersect;\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/Github/phaser-tiled-hull/~/hull.js/src/intersect.js\n// module id = 7\n// module chunks = 0 1"],"sourceRoot":""}