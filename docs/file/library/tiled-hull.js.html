<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">library/tiled-hull.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-injected-style.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/mikewesthad/phaser-tiled-hull" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/library/polygon-edge.js~PolygonEdge.html">PolygonEdge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-phaserTiledHull">phaserTiledHull</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">library/tiled-hull.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import hulljs from &quot;hull.js&quot;; // JS extension required
import PolygonEdge from &quot;./polygon-edge&quot;;

/**
 * A function to take a tilemap layer and process its tiles into clusters. This returns an array of
 * polygons - each polygon encloses a separate cluster of tiles in the tilemap layer.
 *
 * @param {Phaser.TilemapLayer} tilemapLayer The tilemap layer to use for hull calculation.
 * @param {object} [options = {}] Options for filtering the tiles and only allowing certain tiles to
 * be added to the final hulls. If no options specified, then all tiles in the layer will be
 * processed and added to a hull. If multiple options are specified, then a tile only has to match
 * ONE of the options to be added to a hull.
 * @param {number[]} [options.tileIndices = null] An array of tile indices to use for determining
 * which tiles should be clustered together. If a tile&apos;s index matches an index in the array, it
 * will be added to a hull.
 * @param {string} [options.tileProperty = null] The name of a property on tiles (set in Tiled) to
 * use for determining which tiles should be clustered together. If the property is true (or truthy)
 * on a tile, it will be added to a hull.
 * @param {boolean} [options.checkCollide = false] Whether or not a tile&apos;s collide property should
 * be used for determining which tiles should be clustered together. If true, then colliding tiles
 * will be added to a hull.
 * @returns {Array.&lt;PolygonEdge[]&gt;} An array where each element represents a polygon. The polygons
 * are stored as an array of PolygonEdge instances.
 */
export default function phaserTiledHull(tilemapLayer, {tileIndices = null, tileProperty = null, 
        checkCollide = false} = {}) {
    // Separate the tilemap layer into an array of clustered tiles
    const clusters = calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide);
    // Take the clustered tiles and calculate a hull for each cluster
    const pointHulls = calculateHullPoints(clusters);
    // Take the point hulls and turn them into polygon representations (i.e. connect the dots)
    const polyHulls = buildPolygons(pointHulls);
    // Turn the lines in polyHulls into PolygonEdge instances, pre-caching some helpful info like
    // the edge normals
    const hulls = [];
    for (const [i, polyHull] of polyHulls.entries()) {
        const hull = [];
        for (const edge of polyHull) {
            hull.push(new PolygonEdge(edge, i));
        }
        hulls.push(hull);
    }
    return hulls;
}

function calculateClusters(tilemapLayer, tileIndices, tileProperty, checkCollide) {
    const tilemap = tilemapLayer.map;
    const clusters = [];
    const getTile = (tx, ty) =&gt; tilemap.getTile(tx, ty, tilemapLayer.index);
    
    // Loop over all tiles in the map and kick off recursive cluster building
    for (var x = 0; x &lt; tilemap.width; x++) {
        for (var y = 0; y &lt; tilemap.height; y++) {
            const tile = getTile(x, y);
            if (checkTile(tile) &amp;&amp; !findTileInClusters(tile)) {
                const cluster = [];
                recursivelySearchNeighbors(x, y, cluster);
                clusters.push(cluster);
            }
        }
    }

    // Check to make sure the tile passes the checks, i.e. it is allowed to be in a cluster
    function checkTile(tile) {
        // No tile, ignore
        if (!tile) return false;
        // If an array of indices was provided, tile&apos;s index must be in that array
        if (tileIndices &amp;&amp; tileIndices.includes(tile.index)) return true;
        // If a tile property was provided, the tile must have a truthy value for that property
        if (tileProperty &amp;&amp; tile.properties[tileProperty]) return true;
        // If we only care about colliding tiles, make sure the tile collides
        if (checkCollide &amp;&amp; tile.collides) return true;
        // Tile didn&apos;t pass any checks, ignore
        return false;
    }

    function recursivelySearchNeighbors(x, y, cluster) {
        // If tile passes the checks and is not already in the cluster, add it and recursively check
        // the neighbors. Note: There&apos;s no chance of a tile being a member of two separate clusters.
        const tile = getTile(x, y);
        if (checkTile(tile) &amp;&amp; (cluster.indexOf(tile) === -1)) {
            cluster.push(tile); // Add the current tile
            // Search the neighbors
            recursivelySearchNeighbors(x, y - 1, cluster);
            recursivelySearchNeighbors(x, y + 1, cluster);
            recursivelySearchNeighbors(x + 1, y, cluster);
            recursivelySearchNeighbors(x - 1, y, cluster);
        }
    }

    function findTileInClusters(searchTile) {
        for (const cluster of clusters) {
            for (const tile of cluster) {
                if (searchTile === tile) return cluster;
            }
        }
        return null;
    }

    return clusters;
}

function calculateHullPoints(clusters) {
    const hulls = [];

    // Loop over each cluster of tiles in clusters and calculate a polygon hull
    for (const cluster of clusters) {
        // Find all the points - i.e. the corners of each tile in the cluster
        const points = [];
        for (const tile of cluster) {
            points.push(
                [tile.left, tile.top],
                [tile.right, tile.top],                
                [tile.left, tile.bottom],                
                [tile.right, tile.bottom]
            );
        }

        // Use hull.js to find a hull (e.g. points in clockwise order). The second parameter is the 
        // concavity of the hull, with 1 being maximally concave.  
        const hull = hulljs(points, 1);
        hulls.push(hull);
    }

    return hulls;
}

function buildPolygons(hulls) {
    const polygons = [];

    for (const hullPoints of hulls) {
        const edges = [];

        // Walk along the line segments of the hull, collapsing collinear lines into a single edge
        let currentEdge = new Phaser.Line(...hullPoints[0], ...hullPoints[1]);
        let segment;
        for (let i = 1; i &lt; hullPoints.length; i++) {
            // Get the next line segment - starts from the endpoint of the last segment
            segment = new Phaser.Line(...hullPoints[i - 1], ...hullPoints[i]);

            if (checkIfCollinear(currentEdge, segment)) {
                // If the current edge and line segment are collinear, then we haven&apos;t reached the
                // end of the edge yet. Extend the edge to contain the segment.
                currentEdge = new Phaser.Line(
                    currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y
                );
            } else {
                // We&apos;ve reached a corner, so the edge is done. Save it and start a new one.
                edges.push(currentEdge);
                currentEdge = segment.clone();             
            }
        }

        // Process the last line segment - connecting the last point back around to the first point
        segment = new Phaser.Line(...hullPoints[hullPoints.length - 1], ...hullPoints[0]);
        if (checkIfCollinear(currentEdge, segment)) {
            // Extend the edge and add it (since it wasn&apos;t added by the loop above)
            currentEdge = new Phaser.Line(
                currentEdge.start.x, currentEdge.start.y, segment.end.x, segment.end.y
            );
            edges.push(currentEdge);
        } else {
            // Corner - add the edge and the next segment 
            edges.push(currentEdge);
            edges.push(segment);
        }

        // Determine whether the last edge and the first edge need to be merged (if the points in
        // the hull started midway through an edge)
        if (checkIfCollinear(edges[0], edges[edges.length - 1])) {
            const firstLine = edges.shift();
            const lastLine = edges.pop();
            var combinedLine = new Phaser.Line(
                firstLine.start.x, firstLine.start.y, lastLine.end.x, lastLine.end.y
            );
            edges.push(combinedLine);
        }

        // Add the final lines to the polygon
        polygons.push(edges);
    }
    
    return polygons;
}

function checkIfCollinear(line1, line2) {
    // To check if two slopes are equal:
    //  lineDeltaY / lineDeltaX = segmentDeltaY / segmentDeltaX
    // But to avoid dividing by zero:
    //  (lineDeltaX * segmentDeltaY) - (lineDeltaY * segmentDeltaX) = 0
    const dx1 = line1.end.x - line1.start.x;
    const dy1 = line1.end.y - line1.start.y;
    const dx2 = line2.end.x - line2.start.x;
    const dy2 = line2.end.y - line2.start.y;
    return ((dx1 * dy2) - (dy1 * dx2)) === 0;
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
